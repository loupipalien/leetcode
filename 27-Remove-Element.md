## Remove Element
给定一个数组 nums 和值 val, 就地移除所有值等于 val 的实例并返回新的长度  
不能分配额外的空间给另一个数组, 你必须通过使用 $O(1)$ 的额外内存就地改变输入数组  
元素的顺序可以被改变, 超过你返回的新长度之外的都无所谓

#### 示例 1:
```
给定 nums = [3,2,2,3], val = 3,
你的函数应该返回长度 = 2, 并且 nums 的前两位元素是 2, 超过你返回的新长度之外的都无所谓
```

#### 示例 2:
```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
你的函数应该返回长度 = 2, 并且 nums 的前五位元素是 0, 1, 3, 0, 4, 超过你返回的新长度之外的都无所谓
```

#### 说明
疑惑为什么返回值是一个整数但你的答案是一个数组?  
注意, 输入数组是通过引用传递, 这意味着改变输入数组将会被调用这知晓  
你可以这样认为
```
// nums 是通过引用传递 (不能做复制)
int len = removeDuplicates(nums);
// 你的函数对 nums 的任何修改都会被调用者知晓
// 使用你的函数返回的长度, 打印前 len 个元素
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

### 概要
这是一个相当简单的问题, 但是可能在 "就地" 这个词上有疑问, 尽管不复制一份数组从其中移除一个元素是可能的

### 提示
1. 尝试两个指针
2. 你是否使用了 "元素顺序是可以改变" 的性质?
3. 当很少有元素移除会发生什么?

### 解法
#### 方法 1: 两个指针
##### 直觉
因为题目要求我们就地移除所有等于给定值的元素, 我们必须在 $O(1)$ 的额外空间处理它, 如何解决? 我们可以维护两个指针 i 和 j, i 是慢指针而 j 是快指针
##### 算法
 当 nums[j] 等于给定的值时, 跳过这个元素然后 j 自增, 只要 nums[j] != val, 我们就拷贝 nums[j] 到 nums[i] 并且同时增加索引的值, 重复这一过程直到 j 到达数组结尾, i 就是新的长度  
 这个解法和 [Remove Duplicates from Sorted Array](https://leetcode.com/articles/remove-duplicates-from-sorted-array/) 很相似
```
public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j < nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
```
##### 复杂度分析
- 时间复杂度: $O(n)$, 假定数组的元素总数是 n, 并且 i 和 j 遍历至多 2n 步
- 空间复杂度: $O(1)$

#### 方法 2: 两个指针 - 当很少有元素移除时
##### 直觉
现在考虑这样的情形, 当数组中仅包含很少的移除元素; 例如, nums = [1,2,3,5,4], val = 4; 之前的算法将会做前四个元素的非必要的拷贝操作; 另一个例子是 nums = [4,1,2,3,5], val = 4; 在第一步后, [1,2,3,5] 似乎没有必要移除元素, 因为题目描述提到元素的顺序是可以改变的
##### 算法
当我们遇到 nums[i] = val, 我们可以将当前元素与最后一个元素交换, 并且处理最后一个元素的位置, 本质上是将数组减少了 1  
注意最后这个元素可能是你想要移除的值, 不过被担心, 我们会在下一个迭代时检查这个元素
```
public int removeElement(int[] nums, int val) {
    int i = 0;
    int n = nums.length;
    while (i < n) {
        if (nums[i] == val) {
            nums[i] = nums[n - 1];
            // reduce array size by one
            n--;
        } else {
            i++;
        }
    }
    return n;
}
```
##### 复杂度分析
- 时间复杂度: $O(n)$,  i 和 n 遍历都至多需要 n 步; 在这个方法中, 分配的操作数等于要移除的元素个数, 所以当很少元素移除时它更有效率
- 空间复杂度: $O(1)$

>**参考:**
[Remove Element](https://leetcode.com/articles/remove-element/)
